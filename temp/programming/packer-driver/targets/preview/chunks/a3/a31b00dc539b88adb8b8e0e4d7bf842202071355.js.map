{"version":3,"sources":["file:///C:/D-Disk/cocos%20project/ScrollTest/assets/scripts/ScrollViewRendererCtrl.ts"],"names":["_decorator","Component","ccclass","property","ScrollViewRendererCtrl"],"mappings":";;;;;;;;;;AAASA,MAAAA,U,OAAAA,U;AAAYC,MAAAA,S,OAAAA,S;;;;;;;;;OAEf;AAAEC,QAAAA,OAAF;AAAWC,QAAAA;AAAX,O,GAAwBH,U;;wCAGjBI,sB,WADZF,OAAO,CAAC,wBAAD,C,gBAAR,MACaE,sBADb,SAC4CH,SAD5C,CACsD,CAGpD;AACD;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlFqD,O","sourcesContent":["import { _decorator, Component, Node, ScrollView,Vec2,Vec3, Rect, UITransform, UIOpacity } from 'cc';\nimport { ScrollViewPlusItem } from './ScrollViewPlusItem';\nconst { ccclass, property } = _decorator;\n\n@ccclass('ScrollViewRendererCtrl')\nexport class ScrollViewRendererCtrl extends Component {\n\n  \n  // @property(ScrollViewPlus)\n\t// scrollViewPlus: ScrollViewPlus = null;\n\n\t// @property(cc.Prefab)\n\t// scrollViewItemPrefab: cc.Prefab = null;\n\n\t// @property({\n\t// \ttype: cc.EditBox,\n\t// \ttooltip: \"输入需要创建的节点数量\"\n\t// })\n\t// childNodeCountEditBox: cc.EditBox = null;\n\n\t// @property(LoadingDialog)\n\t// loadingDialog: LoadingDialog = null;\n\n\t// onLoad() {\n\t// \tthis.loadingDialog.hide();\n\t// }\n\n\t// async onFramingLoadBtnClick() {\n\t// \tthis.loadingDialog.show();\n\t// \tthis.scrollViewPlus.content.removeAllChildren();\n\t// \tawait this.executePreFrame(this._getItemGenerator(Number.parseInt(this.childNodeCountEditBox.string)), 1);\n\t// \t// 在创建好子节点之后，先手动调用一次DC优化，触发当前在可视区域内的节点的进入逻辑\n\t// \t// 后续的ScrollView滚动时，内部自动回调\n\t// \tthis.scrollViewPlus.optDc();\n\t// \tthis.loadingDialog.hide();\n\t// }\n\n\t// /**\n\t//  * 分帧执行 Generator 逻辑\n\t//  *\n\t//  * @param generator 生成器\n\t//  * @param duration 持续时间（ms），每次执行 Generator 的操作时，最长可持续执行时长。假设值为8ms，那么表示1帧（总共16ms）下，分出8ms时间给此逻辑执行\n\t//  */\n\t// private executePreFrame(generator: Generator, duration: number) {\n\t// \treturn new Promise((resolve, reject) => {\n\t// \t\tlet gen = generator;\n\t// \t\t// 创建执行函数\n\t// \t\tlet execute = () => {\n\t// \t\t\t// 执行之前，先记录开始时间\n\t// \t\t\tlet startTime = new Date().getTime();\n\n\t// \t\t\t// 然后一直从 Generator 中获取已经拆分好的代码段出来执行\n\t// \t\t\tfor (let iter = gen.next(); ; iter = gen.next()) {\n\t// \t\t\t\t// 判断是否已经执行完所有 Generator 的小代码段，如果是的话，那么就表示任务完成\n\t// \t\t\t\tif (iter == null || iter.done) {\n\t// \t\t\t\t\tresolve();\n\t// \t\t\t\t\treturn;\n\t// \t\t\t\t}\n\n\t// \t\t\t\t// 每执行完一段小代码段，都检查一下是否已经超过我们分配的本帧，这些小代码端的最大可执行时间\n\t// \t\t\t\tif (new Date().getTime() - startTime > duration) {\n\t// \t\t\t\t\t// 如果超过了，那么本帧就不在执行，开定时器，让下一帧再执行\n\t// \t\t\t\t\tthis.scheduleOnce(() => {\n\t// \t\t\t\t\t\texecute();\n\t// \t\t\t\t\t});\n\t// \t\t\t\t\treturn;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t};\n\n\t// \t\t// 运行执行函数\n\t// \t\texecute();\n\t// \t});\n\t// }\n\n\t// private *_getItemGenerator(length: number) {\n\t// \tfor (let i = 0; i < length; i++) {\n\t// \t\tyield this._initScrollViewItemPrefab({\n\t// \t\t\tindex: i,\n\t// \t\t\tpicPath: `seed/${i % 12}` // 因为我这里就只有12张图片，所以就用 % 循环了\n\t// \t\t});\n\t// \t}\n\t// }\n\t// private _initScrollViewItemPrefab(data: SeedPicItemData) {\n\t// \tlet itemNode = cc.instantiate(this.scrollViewItemPrefab);\n\t// \titemNode.parent = this.scrollViewPlus.content;\n\t// \titemNode.getComponent(SeedPicItemPrefab).bindData(data);\n\t// }\n    \n    \n}\n"]}